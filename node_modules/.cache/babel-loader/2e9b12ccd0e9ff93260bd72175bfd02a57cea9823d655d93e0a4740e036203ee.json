{"ast":null,"code":"import { parseRating, parsePublicationYear, inferGenre, getEra } from './parseData';\nexport const calculateStats = (books, userName = 'Reader') => {\n  const stats = {\n    name: userName,\n    totalBooks: books.length\n  };\n\n  // Parse all ratings\n  const ratings = books.map(b => parseRating(b.rating)).filter(r => r !== null);\n  if (ratings.length > 0) {\n    stats.avgRating = parseFloat((ratings.reduce((a, b) => a + b, 0) / ratings.length).toFixed(2));\n    stats.fiveStarPct = parseFloat((ratings.filter(r => r === 5).length / ratings.length * 100).toFixed(1));\n    stats.fourPlusPct = parseFloat((ratings.filter(r => r >= 4).length / ratings.length * 100).toFixed(1));\n    stats.mostCommonRating = getMostCommon(ratings);\n\n    // Rating distribution\n    stats.ratingDistribution = {};\n    for (let i = 1; i <= 5; i++) {\n      const count = ratings.filter(r => r === i).length;\n      if (count > 0) stats.ratingDistribution[i] = count;\n    }\n\n    // Compare to Goodreads average\n    const validComparisons = books.filter(b => parseRating(b.rating) !== null && b.avgRating > 0);\n    if (validComparisons.length > 0) {\n      const diff = validComparisons.reduce((sum, b) => {\n        return sum + (parseRating(b.rating) - b.avgRating);\n      }, 0) / validComparisons.length;\n      stats.ratingVsGoodreads = parseFloat(diff.toFixed(2));\n      if (diff > 0.3) {\n        stats.ratingPersonality = \"Generous Reviewer\";\n      } else if (diff < -0.3) {\n        stats.ratingPersonality = \"Tough Critic\";\n      } else {\n        stats.ratingPersonality = \"Balanced Judge\";\n      }\n    }\n  }\n\n  // Publication year stats\n  const years = books.map(b => parsePublicationYear(b.datePublished)).filter(y => y !== null);\n  if (years.length > 0) {\n    stats.avgPubYear = Math.round(years.reduce((a, b) => a + b, 0) / years.length);\n    stats.oldestBookYear = Math.min(...years);\n    stats.newestBookYear = Math.max(...years);\n    stats.timeSpanYears = stats.newestBookYear - stats.oldestBookYear;\n\n    // Find oldest book\n    const oldestBook = books.find(b => parsePublicationYear(b.datePublished) === stats.oldestBookYear);\n    stats.oldestBookTitle = (oldestBook === null || oldestBook === void 0 ? void 0 : oldestBook.title) || 'Unknown';\n\n    // Era breakdown\n    const eras = years.map(getEra);\n    stats.favoriteEra = getMostCommon(eras);\n    stats.eraBreakdown = countOccurrences(eras);\n\n    // Time period counts\n    stats.books2020Plus = years.filter(y => y >= 2020).length;\n    stats.booksPre1900 = years.filter(y => y < 1900).length;\n    stats.booksAncient = years.filter(y => y < 500).length;\n\n    // Reading personality\n    const ancientPct = stats.booksPre1900 / years.length;\n    const recentPct = stats.books2020Plus / years.length;\n    if (ancientPct > 0.3) {\n      stats.readingPersonality = \"Time Traveler\";\n    } else if (recentPct > 0.7) {\n      stats.readingPersonality = \"Trend Chaser\";\n    } else {\n      stats.readingPersonality = \"Balanced Reader\";\n    }\n  }\n\n  // Author stats\n  const authors = books.map(b => b.author).filter(a => a);\n  if (authors.length > 0) {\n    stats.uniqueAuthors = new Set(authors).size;\n    stats.booksPerAuthor = parseFloat((authors.length / stats.uniqueAuthors).toFixed(2));\n    const authorCounts = countOccurrences(authors);\n    const topAuthor = Object.entries(authorCounts).sort((a, b) => b[1] - a[1])[0];\n    stats.topAuthorName = topAuthor[0];\n    stats.topAuthorCount = topAuthor[1];\n    if (authors.length >= 5) {\n      if (stats.booksPerAuthor >= 2.0) {\n        stats.authorLoyalty = \"Superfan\";\n      } else if (stats.booksPerAuthor < 1.2) {\n        stats.authorLoyalty = \"Explorer\";\n      } else {\n        stats.authorLoyalty = \"Balanced\";\n      }\n    }\n  }\n\n  // Genre stats\n  const genres = books.map(b => inferGenre(b.title));\n  stats.topGenre = getMostCommon(genres);\n  stats.genreBreakdown = countOccurrences(genres);\n  stats.genreDiversity = Object.keys(stats.genreBreakdown).length;\n\n  // Goodreads community average\n  const validAvgRatings = books.filter(b => b.avgRating > 0).map(b => b.avgRating);\n  if (validAvgRatings.length > 0) {\n    stats.goodreadsAvg = parseFloat((validAvgRatings.reduce((a, b) => a + b, 0) / validAvgRatings.length).toFixed(2));\n    if (stats.avgRating) {\n      const diff = Math.abs(stats.avgRating - stats.goodreadsAvg);\n      if (diff < 0.3) {\n        stats.tasteAlignment = \"Mainstream\";\n      } else if (stats.avgRating > stats.goodreadsAvg) {\n        stats.tasteAlignment = \"Optimist\";\n      } else {\n        stats.tasteAlignment = \"Contrarian\";\n      }\n    }\n  }\n  return stats;\n};\nconst getMostCommon = arr => {\n  var _Object$entries$sort$;\n  const counts = countOccurrences(arr);\n  return (_Object$entries$sort$ = Object.entries(counts).sort((a, b) => b[1] - a[1])[0]) === null || _Object$entries$sort$ === void 0 ? void 0 : _Object$entries$sort$[0];\n};\nconst countOccurrences = arr => {\n  return arr.reduce((acc, val) => {\n    acc[val] = (acc[val] || 0) + 1;\n    return acc;\n  }, {});\n};","map":{"version":3,"names":["parseRating","parsePublicationYear","inferGenre","getEra","calculateStats","books","userName","stats","name","totalBooks","length","ratings","map","b","rating","filter","r","avgRating","parseFloat","reduce","a","toFixed","fiveStarPct","fourPlusPct","mostCommonRating","getMostCommon","ratingDistribution","i","count","validComparisons","diff","sum","ratingVsGoodreads","ratingPersonality","years","datePublished","y","avgPubYear","Math","round","oldestBookYear","min","newestBookYear","max","timeSpanYears","oldestBook","find","oldestBookTitle","title","eras","favoriteEra","eraBreakdown","countOccurrences","books2020Plus","booksPre1900","booksAncient","ancientPct","recentPct","readingPersonality","authors","author","uniqueAuthors","Set","size","booksPerAuthor","authorCounts","topAuthor","Object","entries","sort","topAuthorName","topAuthorCount","authorLoyalty","genres","topGenre","genreBreakdown","genreDiversity","keys","validAvgRatings","goodreadsAvg","abs","tasteAlignment","arr","_Object$entries$sort$","counts","acc","val"],"sources":["/Users/calebwoods/Desktop/reading-wrapped/src/utils/calculateStats.js"],"sourcesContent":["import { parseRating, parsePublicationYear, inferGenre, getEra } from './parseData';\n\nexport const calculateStats = (books, userName = 'Reader') => {\n    const stats = {\n        name: userName,\n        totalBooks: books.length\n    };\n\n    // Parse all ratings\n    const ratings = books.map(b => parseRating(b.rating)).filter(r => r !== null);\n\n    if (ratings.length > 0) {\n        stats.avgRating = parseFloat((ratings.reduce((a, b) => a + b, 0) / ratings.length).toFixed(2));\n        stats.fiveStarPct = parseFloat(((ratings.filter(r => r === 5).length / ratings.length) * 100).toFixed(1));\n        stats.fourPlusPct = parseFloat(((ratings.filter(r => r >= 4).length / ratings.length) * 100).toFixed(1));\n        stats.mostCommonRating = getMostCommon(ratings);\n\n        // Rating distribution\n        stats.ratingDistribution = {};\n        for (let i = 1; i <= 5; i++) {\n            const count = ratings.filter(r => r === i).length;\n            if (count > 0) stats.ratingDistribution[i] = count;\n        }\n\n        // Compare to Goodreads average\n        const validComparisons = books.filter(b => parseRating(b.rating) !== null && b.avgRating > 0);\n        if (validComparisons.length > 0) {\n            const diff = validComparisons.reduce((sum, b) => {\n                return sum + (parseRating(b.rating) - b.avgRating);\n            }, 0) / validComparisons.length;\n            stats.ratingVsGoodreads = parseFloat(diff.toFixed(2));\n\n            if (diff > 0.3) {\n                stats.ratingPersonality = \"Generous Reviewer\";\n            } else if (diff < -0.3) {\n                stats.ratingPersonality = \"Tough Critic\";\n            } else {\n                stats.ratingPersonality = \"Balanced Judge\";\n            }\n        }\n    }\n\n    // Publication year stats\n    const years = books.map(b => parsePublicationYear(b.datePublished)).filter(y => y !== null);\n\n    if (years.length > 0) {\n        stats.avgPubYear = Math.round(years.reduce((a, b) => a + b, 0) / years.length);\n        stats.oldestBookYear = Math.min(...years);\n        stats.newestBookYear = Math.max(...years);\n        stats.timeSpanYears = stats.newestBookYear - stats.oldestBookYear;\n\n        // Find oldest book\n        const oldestBook = books.find(b => parsePublicationYear(b.datePublished) === stats.oldestBookYear);\n        stats.oldestBookTitle = oldestBook?.title || 'Unknown';\n\n        // Era breakdown\n        const eras = years.map(getEra);\n        stats.favoriteEra = getMostCommon(eras);\n        stats.eraBreakdown = countOccurrences(eras);\n\n        // Time period counts\n        stats.books2020Plus = years.filter(y => y >= 2020).length;\n        stats.booksPre1900 = years.filter(y => y < 1900).length;\n        stats.booksAncient = years.filter(y => y < 500).length;\n\n        // Reading personality\n        const ancientPct = stats.booksPre1900 / years.length;\n        const recentPct = stats.books2020Plus / years.length;\n\n        if (ancientPct > 0.3) {\n            stats.readingPersonality = \"Time Traveler\";\n        } else if (recentPct > 0.7) {\n            stats.readingPersonality = \"Trend Chaser\";\n        } else {\n            stats.readingPersonality = \"Balanced Reader\";\n        }\n    }\n\n    // Author stats\n    const authors = books.map(b => b.author).filter(a => a);\n\n    if (authors.length > 0) {\n        stats.uniqueAuthors = new Set(authors).size;\n        stats.booksPerAuthor = parseFloat((authors.length / stats.uniqueAuthors).toFixed(2));\n\n        const authorCounts = countOccurrences(authors);\n        const topAuthor = Object.entries(authorCounts).sort((a, b) => b[1] - a[1])[0];\n        stats.topAuthorName = topAuthor[0];\n        stats.topAuthorCount = topAuthor[1];\n\n        if (authors.length >= 5) {\n            if (stats.booksPerAuthor >= 2.0) {\n                stats.authorLoyalty = \"Superfan\";\n            } else if (stats.booksPerAuthor < 1.2) {\n                stats.authorLoyalty = \"Explorer\";\n            } else {\n                stats.authorLoyalty = \"Balanced\";\n            }\n        }\n    }\n\n    // Genre stats\n    const genres = books.map(b => inferGenre(b.title));\n    stats.topGenre = getMostCommon(genres);\n    stats.genreBreakdown = countOccurrences(genres);\n    stats.genreDiversity = Object.keys(stats.genreBreakdown).length;\n\n    // Goodreads community average\n    const validAvgRatings = books.filter(b => b.avgRating > 0).map(b => b.avgRating);\n    if (validAvgRatings.length > 0) {\n        stats.goodreadsAvg = parseFloat((validAvgRatings.reduce((a, b) => a + b, 0) / validAvgRatings.length).toFixed(2));\n\n        if (stats.avgRating) {\n            const diff = Math.abs(stats.avgRating - stats.goodreadsAvg);\n            if (diff < 0.3) {\n                stats.tasteAlignment = \"Mainstream\";\n            } else if (stats.avgRating > stats.goodreadsAvg) {\n                stats.tasteAlignment = \"Optimist\";\n            } else {\n                stats.tasteAlignment = \"Contrarian\";\n            }\n        }\n    }\n\n    return stats;\n};\n\nconst getMostCommon = (arr) => {\n    const counts = countOccurrences(arr);\n    return Object.entries(counts).sort((a, b) => b[1] - a[1])[0]?.[0];\n};\n\nconst countOccurrences = (arr) => {\n    return arr.reduce((acc, val) => {\n        acc[val] = (acc[val] || 0) + 1;\n        return acc;\n    }, {});\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import Papa from 'papaparse';\nimport * as XLSX from 'xlsx';\nexport const parseFile = file => {\n  return new Promise((resolve, reject) => {\n    const fileName = file.name.toLowerCase();\n    if (fileName.endsWith('.csv')) {\n      // Parse CSV\n      Papa.parse(file, {\n        complete: results => {\n          resolve(parseGoodreadsData(results.data));\n        },\n        error: error => {\n          reject(new Error('Failed to parse CSV: ' + error.message));\n        },\n        header: true,\n        skipEmptyLines: true\n      });\n    } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {\n      // Parse Excel\n      const reader = new FileReader();\n      reader.onload = e => {\n        try {\n          const data = new Uint8Array(e.target.result);\n          const workbook = XLSX.read(data, {\n            type: 'array'\n          });\n          const firstSheet = workbook.Sheets[workbook.SheetNames[0]];\n          const jsonData = XLSX.utils.sheet_to_json(firstSheet);\n          resolve(parseGoodreadsData(jsonData));\n        } catch (error) {\n          reject(new Error('Failed to parse Excel: ' + error.message));\n        }\n      };\n      reader.onerror = () => reject(new Error('Failed to read file'));\n      reader.readAsArrayBuffer(file);\n    } else {\n      reject(new Error('Unsupported file format. Please upload CSV or Excel file.'));\n    }\n  });\n};\nconst parseGoodreadsData = data => {\n  // Filter out empty rows\n  const books = data.filter(row => row.Title || row.title);\n  return books.map(row => {\n    // Handle different column name formats (Goodreads CSV uses Title, custom exports might use title)\n    const getField = field => {\n      const lowerField = field.toLowerCase();\n      const key = Object.keys(row).find(k => k.toLowerCase() === lowerField);\n      return row[key];\n    };\n    return {\n      title: getField('title') || '',\n      author: getField('author') || '',\n      rating: getField('my rating') || getField('rating') || '',\n      avgRating: parseFloat(getField('average rating') || getField('avg rating') || 0),\n      dateRead: getField('date read') || getField('date   read') || '',\n      datePublished: getField('original publication year') || getField('date pub') || '',\n      isbn: getField('isbn') || getField('isbn13') || '',\n      shelves: getField('bookshelves') || getField('shelves') || ''\n    };\n  });\n};\nexport const parseRating = ratingStr => {\n  if (!ratingStr) return null;\n  const str = String(ratingStr);\n\n  // Look for bracketed rating (actual rating given)\n  const bracketMatch = str.match(/\\[\\s*(\\d)\\s*of 5 stars\\s*\\]/);\n  if (bracketMatch) return parseInt(bracketMatch[1]);\n\n  // Look for any number in \"X of 5 stars\" format\n  const starMatch = str.match(/(\\d)\\s*of 5 stars/);\n  if (starMatch) return parseInt(starMatch[1]);\n\n  // Text ratings\n  const textRatings = {\n    'it was amazing': 5,\n    'really liked it': 4,\n    'liked it': 3,\n    'it was ok': 2,\n    'did not like it': 1\n  };\n  return textRatings[str.toLowerCase()] || null;\n};\nexport const parsePublicationYear = dateVal => {\n  if (!dateVal) return null;\n  const str = String(dateVal);\n  if (str.toLowerCase() === 'unknown') return null;\n\n  // Extract year from string\n  const yearMatch = str.match(/\\b(\\d{4})\\b/);\n  if (yearMatch) {\n    const year = parseInt(yearMatch[1]);\n    if (year >= -5000 && year <= 2025) return year;\n  }\n\n  // Handle negative years (BC)\n  if (str.startsWith('-')) {\n    try {\n      const year = parseInt(str);\n      if (year >= -5000 && year <= 0) return year;\n    } catch (e) {\n      // ignore\n    }\n  }\n  return null;\n};\nexport const inferGenre = title => {\n  const titleLower = String(title).toLowerCase();\n  if (/theology|god|christ|gospel|faith|prayer|christian|holy|doxology/.test(titleLower)) {\n    return 'Theology/Religion';\n  } else if (/philosophy|ethics|republic|nicomachean/.test(titleLower)) {\n    return 'Philosophy';\n  } else if (/history|war|political|world/.test(titleLower)) {\n    return 'History/Politics';\n  } else if (/love|heart|romance|kiss|rose|fates|blood|vampire|fae|fate|stars/.test(titleLower)) {\n    return 'Romance/Fantasy';\n  } else if (/guide|how to|handbook|manual|empathy|toxic|discipline|parenting|pregnancy|childbirth|leadership/.test(titleLower)) {\n    return 'Self-Help/Practical';\n  } else {\n    return 'Fiction/Other';\n  }\n};\nexport const getEra = year => {\n  if (year < 0) return \"Ancient (BC)\";\n  if (year < 500) return \"Ancient\";\n  if (year < 1500) return \"Medieval\";\n  if (year < 1800) return \"Early Modern\";\n  if (year < 1900) return \"19th Century\";\n  if (year < 2000) return \"20th Century\";\n  return \"21st Century\";\n};","map":{"version":3,"names":["Papa","XLSX","parseFile","file","Promise","resolve","reject","fileName","name","toLowerCase","endsWith","parse","complete","results","parseGoodreadsData","data","error","Error","message","header","skipEmptyLines","reader","FileReader","onload","e","Uint8Array","target","result","workbook","read","type","firstSheet","Sheets","SheetNames","jsonData","utils","sheet_to_json","onerror","readAsArrayBuffer","books","filter","row","Title","title","map","getField","field","lowerField","key","Object","keys","find","k","author","rating","avgRating","parseFloat","dateRead","datePublished","isbn","shelves","parseRating","ratingStr","str","String","bracketMatch","match","parseInt","starMatch","textRatings","parsePublicationYear","dateVal","yearMatch","year","startsWith","inferGenre","titleLower","test","getEra"],"sources":["/Users/calebwoods/Desktop/reading-wrapped/src/utils/parseData.js"],"sourcesContent":["import Papa from 'papaparse';\nimport * as XLSX from 'xlsx';\n\nexport const parseFile = (file) => {\n    return new Promise((resolve, reject) => {\n        const fileName = file.name.toLowerCase();\n\n        if (fileName.endsWith('.csv')) {\n            // Parse CSV\n            Papa.parse(file, {\n                complete: (results) => {\n                    resolve(parseGoodreadsData(results.data));\n                },\n                error: (error) => {\n                    reject(new Error('Failed to parse CSV: ' + error.message));\n                },\n                header: true,\n                skipEmptyLines: true\n            });\n        } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {\n            // Parse Excel\n            const reader = new FileReader();\n            reader.onload = (e) => {\n                try {\n                    const data = new Uint8Array(e.target.result);\n                    const workbook = XLSX.read(data, { type: 'array' });\n                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];\n                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);\n                    resolve(parseGoodreadsData(jsonData));\n                } catch (error) {\n                    reject(new Error('Failed to parse Excel: ' + error.message));\n                }\n            };\n            reader.onerror = () => reject(new Error('Failed to read file'));\n            reader.readAsArrayBuffer(file);\n        } else {\n            reject(new Error('Unsupported file format. Please upload CSV or Excel file.'));\n        }\n    });\n};\n\nconst parseGoodreadsData = (data) => {\n    // Filter out empty rows\n    const books = data.filter(row => row.Title || row.title);\n\n    return books.map(row => {\n        // Handle different column name formats (Goodreads CSV uses Title, custom exports might use title)\n        const getField = (field) => {\n            const lowerField = field.toLowerCase();\n            const key = Object.keys(row).find(k => k.toLowerCase() === lowerField);\n            return row[key];\n        };\n\n        return {\n            title: getField('title') || '',\n            author: getField('author') || '',\n            rating: getField('my rating') || getField('rating') || '',\n            avgRating: parseFloat(getField('average rating') || getField('avg rating') || 0),\n            dateRead: getField('date read') || getField('date   read') || '',\n            datePublished: getField('original publication year') || getField('date pub') || '',\n            isbn: getField('isbn') || getField('isbn13') || '',\n            shelves: getField('bookshelves') || getField('shelves') || ''\n        };\n    });\n};\n\nexport const parseRating = (ratingStr) => {\n    if (!ratingStr) return null;\n\n    const str = String(ratingStr);\n\n    // Look for bracketed rating (actual rating given)\n    const bracketMatch = str.match(/\\[\\s*(\\d)\\s*of 5 stars\\s*\\]/);\n    if (bracketMatch) return parseInt(bracketMatch[1]);\n\n    // Look for any number in \"X of 5 stars\" format\n    const starMatch = str.match(/(\\d)\\s*of 5 stars/);\n    if (starMatch) return parseInt(starMatch[1]);\n\n    // Text ratings\n    const textRatings = {\n        'it was amazing': 5,\n        'really liked it': 4,\n        'liked it': 3,\n        'it was ok': 2,\n        'did not like it': 1\n    };\n\n    return textRatings[str.toLowerCase()] || null;\n};\n\nexport const parsePublicationYear = (dateVal) => {\n    if (!dateVal) return null;\n\n    const str = String(dateVal);\n    if (str.toLowerCase() === 'unknown') return null;\n\n    // Extract year from string\n    const yearMatch = str.match(/\\b(\\d{4})\\b/);\n    if (yearMatch) {\n        const year = parseInt(yearMatch[1]);\n        if (year >= -5000 && year <= 2025) return year;\n    }\n\n    // Handle negative years (BC)\n    if (str.startsWith('-')) {\n        try {\n            const year = parseInt(str);\n            if (year >= -5000 && year <= 0) return year;\n        } catch (e) {\n            // ignore\n        }\n    }\n\n    return null;\n};\n\nexport const inferGenre = (title) => {\n    const titleLower = String(title).toLowerCase();\n\n    if (/theology|god|christ|gospel|faith|prayer|christian|holy|doxology/.test(titleLower)) {\n        return 'Theology/Religion';\n    } else if (/philosophy|ethics|republic|nicomachean/.test(titleLower)) {\n        return 'Philosophy';\n    } else if (/history|war|political|world/.test(titleLower)) {\n        return 'History/Politics';\n    } else if (/love|heart|romance|kiss|rose|fates|blood|vampire|fae|fate|stars/.test(titleLower)) {\n        return 'Romance/Fantasy';\n    } else if (/guide|how to|handbook|manual|empathy|toxic|discipline|parenting|pregnancy|childbirth|leadership/.test(titleLower)) {\n        return 'Self-Help/Practical';\n    } else {\n        return 'Fiction/Other';\n    }\n};\n\nexport const getEra = (year) => {\n    if (year < 0) return \"Ancient (BC)\";\n    if (year < 500) return \"Ancient\";\n    if (year < 1500) return \"Medieval\";\n    if (year < 1800) return \"Early Modern\";\n    if (year < 1900) return \"19th Century\";\n    if (year < 2000) return \"20th Century\";\n    return \"21st Century\";\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { parseRating, parsePublicationYear, inferGenre, getEra } from './parseData';\nexport const calculateStats = (books, userName = 'Reader', year = null) => {\n  const stats = {\n    name: userName,\n    year: year,\n    totalBooks: books.length\n  };\n  const pagesRead = books.map(b => {\n    const pages = parseInt(b.pages || b['Number of Pages'] || 0);\n    return isNaN(pages) ? 0 : pages;\n  }).reduce((sum, pages) => sum + pages, 0);\n  stats.totalPages = pagesRead;\n\n  // Parse all ratings\n  const ratings = books.map(b => parseRating(b.rating)).filter(r => r !== null);\n  if (ratings.length > 0) {\n    stats.avgRating = parseFloat((ratings.reduce((a, b) => a + b, 0) / ratings.length).toFixed(2));\n    stats.fiveStarPct = parseFloat((ratings.filter(r => r === 5).length / ratings.length * 100).toFixed(1));\n    stats.fourPlusPct = parseFloat((ratings.filter(r => r >= 4).length / ratings.length * 100).toFixed(1));\n    stats.mostCommonRating = getMostCommon(ratings);\n\n    // Rating distribution\n    stats.ratingDistribution = {};\n    for (let i = 1; i <= 5; i++) {\n      const count = ratings.filter(r => r === i).length;\n      if (count > 0) stats.ratingDistribution[i] = count;\n    }\n\n    // Compare to Goodreads average\n    const validComparisons = books.filter(b => parseRating(b.rating) !== null && b.avgRating > 0);\n    if (validComparisons.length > 0) {\n      const diff = validComparisons.reduce((sum, b) => {\n        return sum + (parseRating(b.rating) - b.avgRating);\n      }, 0) / validComparisons.length;\n      stats.ratingVsGoodreads = parseFloat(diff.toFixed(2));\n      if (diff > 0.3) {\n        stats.ratingPersonality = \"Generous Reviewer\";\n      } else if (diff < -0.3) {\n        stats.ratingPersonality = \"Tough Critic\";\n      } else {\n        stats.ratingPersonality = \"Balanced Judge\";\n      }\n\n      // NEW: Advanced rating analysis\n      stats.ratingAnalysis = analyzeRatingBehavior(validComparisons);\n    }\n  }\n\n  // Publication year stats\n  const years = books.map(b => parsePublicationYear(b.datePublished)).filter(y => y !== null);\n  if (years.length > 0) {\n    stats.avgPubYear = Math.round(years.reduce((a, b) => a + b, 0) / years.length);\n    stats.oldestBookYear = Math.min(...years);\n    stats.newestBookYear = Math.max(...years);\n    stats.timeSpanYears = stats.newestBookYear - stats.oldestBookYear;\n\n    // Find oldest book\n    const oldestBook = books.find(b => parsePublicationYear(b.datePublished) === stats.oldestBookYear);\n    stats.oldestBookTitle = (oldestBook === null || oldestBook === void 0 ? void 0 : oldestBook.title) || 'Unknown';\n\n    // Era breakdown\n    const eras = years.map(getEra);\n    stats.favoriteEra = getMostCommon(eras);\n    stats.eraBreakdown = countOccurrences(eras);\n\n    // Time period counts\n    stats.books2020Plus = years.filter(y => y >= 2020).length;\n    stats.booksPre1900 = years.filter(y => y < 1900).length;\n    stats.booksAncient = years.filter(y => y < 500).length;\n\n    // Reading personality\n    const ancientPct = stats.booksPre1900 / years.length;\n    const recentPct = stats.books2020Plus / years.length;\n    if (ancientPct > 0.3) {\n      stats.readingPersonality = \"Time Traveler\";\n    } else if (recentPct > 0.7) {\n      stats.readingPersonality = \"Trend Chaser\";\n    } else {\n      stats.readingPersonality = \"Balanced Reader\";\n    }\n  }\n\n  // Author stats\n  const authors = books.map(b => b.author).filter(a => a);\n  if (authors.length > 0) {\n    stats.uniqueAuthors = new Set(authors).size;\n    stats.booksPerAuthor = parseFloat((authors.length / stats.uniqueAuthors).toFixed(2));\n    const authorCounts = countOccurrences(authors);\n    const topAuthor = Object.entries(authorCounts).sort((a, b) => b[1] - a[1])[0];\n    stats.topAuthorName = topAuthor[0];\n    stats.topAuthorCount = topAuthor[1];\n    if (authors.length >= 5) {\n      if (stats.booksPerAuthor >= 2.0) {\n        stats.authorLoyalty = \"Superfan\";\n      } else if (stats.booksPerAuthor < 1.2) {\n        stats.authorLoyalty = \"Explorer\";\n      } else {\n        stats.authorLoyalty = \"Balanced\";\n      }\n    }\n  }\n\n  // Genre stats\n  const genres = books.map(b => inferGenre(b.title));\n  stats.topGenre = getMostCommon(genres);\n  stats.genreBreakdown = countOccurrences(genres);\n  stats.genreDiversity = Object.keys(stats.genreBreakdown).length;\n\n  // Goodreads community average\n  const validAvgRatings = books.filter(b => b.avgRating > 0).map(b => b.avgRating);\n  if (validAvgRatings.length > 0) {\n    stats.goodreadsAvg = parseFloat((validAvgRatings.reduce((a, b) => a + b, 0) / validAvgRatings.length).toFixed(2));\n    if (stats.avgRating) {\n      const diff = Math.abs(stats.avgRating - stats.goodreadsAvg);\n      if (diff < 0.3) {\n        stats.tasteAlignment = \"Mainstream\";\n      } else if (stats.avgRating > stats.goodreadsAvg) {\n        stats.tasteAlignment = \"Optimist\";\n      } else {\n        stats.tasteAlignment = \"Contrarian\";\n      }\n    }\n  }\n  return stats;\n};\n\n// NEW: Analyze rating behavior in detail\nconst analyzeRatingBehavior = booksWithComparisons => {\n  const analysis = {};\n\n  // Books where user rated higher than Goodreads\n  const ratedHigher = booksWithComparisons.filter(b => {\n    const userRating = parseRating(b.rating);\n    return userRating > b.avgRating;\n  });\n\n  // Books where user rated lower than Goodreads\n  const ratedLower = booksWithComparisons.filter(b => {\n    const userRating = parseRating(b.rating);\n    return userRating < b.avgRating;\n  });\n\n  // Books rated exactly the same\n  const ratedSame = booksWithComparisons.filter(b => {\n    const userRating = parseRating(b.rating);\n    return Math.abs(userRating - b.avgRating) < 0.1;\n  });\n  analysis.ratedHigherCount = ratedHigher.length;\n  analysis.ratedLowerCount = ratedLower.length;\n  analysis.ratedSameCount = ratedSame.length;\n  analysis.ratedHigherPct = parseFloat((ratedHigher.length / booksWithComparisons.length * 100).toFixed(1));\n  analysis.ratedLowerPct = parseFloat((ratedLower.length / booksWithComparisons.length * 100).toFixed(1));\n\n  // Find biggest disagreements\n  const disagreements = booksWithComparisons.map(b => ({\n    title: b.title,\n    userRating: parseRating(b.rating),\n    avgRating: b.avgRating,\n    difference: parseRating(b.rating) - b.avgRating\n  }));\n\n  // Most loved (rated much higher than average)\n  const mostLoved = disagreements.filter(d => d.difference > 0).sort((a, b) => b.difference - a.difference).slice(0, 3);\n\n  // Most critical (rated much lower than average)\n  const mostCritical = disagreements.filter(d => d.difference < 0).sort((a, b) => a.difference - b.difference).slice(0, 3);\n  analysis.mostLoved = mostLoved;\n  analysis.mostCritical = mostCritical;\n\n  // Underrated gems (gave 5 stars, Goodreads average < 4.0)\n  const underratedGems = booksWithComparisons.filter(b => {\n    const userRating = parseRating(b.rating);\n    return userRating === 5 && b.avgRating < 4.0;\n  });\n  analysis.underratedGems = underratedGems.map(b => ({\n    title: b.title,\n    avgRating: b.avgRating\n  }));\n\n  // Overrated books (gave 1-2 stars, Goodreads average > 4.0)\n  const overratedBooks = booksWithComparisons.filter(b => {\n    const userRating = parseRating(b.rating);\n    return userRating <= 2 && b.avgRating > 4.0;\n  });\n  analysis.overratedBooks = overratedBooks.map(b => ({\n    title: b.title,\n    avgRating: b.avgRating,\n    userRating: parseRating(b.rating)\n  }));\n\n  // Rating consistency - standard deviation\n  const differences = disagreements.map(d => d.difference);\n  const avgDiff = differences.reduce((a, b) => a + b, 0) / differences.length;\n  const variance = differences.reduce((sum, diff) => sum + Math.pow(diff - avgDiff, 2), 0) / differences.length;\n  analysis.ratingStdDev = parseFloat(Math.sqrt(variance).toFixed(2));\n\n  // Determine consistency personality\n  if (analysis.ratingStdDev < 0.5) {\n    analysis.consistencyType = \"Predictable\";\n  } else if (analysis.ratingStdDev > 1.0) {\n    analysis.consistencyType = \"Unpredictable\";\n  } else {\n    analysis.consistencyType = \"Moderate\";\n  }\n\n  // Harsh on popular books?\n  const popularBooks = booksWithComparisons.filter(b => b.avgRating >= 4.2);\n  if (popularBooks.length > 0) {\n    const popularAvgDiff = popularBooks.reduce((sum, b) => {\n      return sum + (parseRating(b.rating) - b.avgRating);\n    }, 0) / popularBooks.length;\n    analysis.harshOnPopular = popularAvgDiff < -0.3;\n  }\n\n  // Champion of underdogs?\n  const unpopularBooks = booksWithComparisons.filter(b => b.avgRating < 3.8);\n  if (unpopularBooks.length > 0) {\n    const unpopularAvgDiff = unpopularBooks.reduce((sum, b) => {\n      return sum + (parseRating(b.rating) - b.avgRating);\n    }, 0) / unpopularBooks.length;\n    analysis.championOfUnderdogs = unpopularAvgDiff > 0.3;\n  }\n  return analysis;\n};\nconst getMostCommon = arr => {\n  var _Object$entries$sort$;\n  const counts = countOccurrences(arr);\n  return (_Object$entries$sort$ = Object.entries(counts).sort((a, b) => b[1] - a[1])[0]) === null || _Object$entries$sort$ === void 0 ? void 0 : _Object$entries$sort$[0];\n};\nconst countOccurrences = arr => {\n  return arr.reduce((acc, val) => {\n    acc[val] = (acc[val] || 0) + 1;\n    return acc;\n  }, {});\n};","map":{"version":3,"names":["parseRating","parsePublicationYear","inferGenre","getEra","calculateStats","books","userName","year","stats","name","totalBooks","length","pagesRead","map","b","pages","parseInt","isNaN","reduce","sum","totalPages","ratings","rating","filter","r","avgRating","parseFloat","a","toFixed","fiveStarPct","fourPlusPct","mostCommonRating","getMostCommon","ratingDistribution","i","count","validComparisons","diff","ratingVsGoodreads","ratingPersonality","ratingAnalysis","analyzeRatingBehavior","years","datePublished","y","avgPubYear","Math","round","oldestBookYear","min","newestBookYear","max","timeSpanYears","oldestBook","find","oldestBookTitle","title","eras","favoriteEra","eraBreakdown","countOccurrences","books2020Plus","booksPre1900","booksAncient","ancientPct","recentPct","readingPersonality","authors","author","uniqueAuthors","Set","size","booksPerAuthor","authorCounts","topAuthor","Object","entries","sort","topAuthorName","topAuthorCount","authorLoyalty","genres","topGenre","genreBreakdown","genreDiversity","keys","validAvgRatings","goodreadsAvg","abs","tasteAlignment","booksWithComparisons","analysis","ratedHigher","userRating","ratedLower","ratedSame","ratedHigherCount","ratedLowerCount","ratedSameCount","ratedHigherPct","ratedLowerPct","disagreements","difference","mostLoved","d","slice","mostCritical","underratedGems","overratedBooks","differences","avgDiff","variance","pow","ratingStdDev","sqrt","consistencyType","popularBooks","popularAvgDiff","harshOnPopular","unpopularBooks","unpopularAvgDiff","championOfUnderdogs","arr","_Object$entries$sort$","counts","acc","val"],"sources":["/Users/calebwoods/Desktop/reading-wrapped/src/utils/calculateStats.js"],"sourcesContent":["import { parseRating, parsePublicationYear, inferGenre, getEra } from './parseData';\n\nexport const calculateStats = (books, userName = 'Reader', year = null) => {\n    const stats = {\n        name: userName,\n        year: year,\n        totalBooks: books.length\n    };\n\n    const pagesRead = books\n        .map(b => {\n            const pages = parseInt(b.pages || b['Number of Pages'] || 0);\n            return isNaN(pages) ? 0 : pages;\n        })\n        .reduce((sum, pages) => sum + pages, 0);\n\n    stats.totalPages = pagesRead;\n\n\n    // Parse all ratings\n    const ratings = books.map(b => parseRating(b.rating)).filter(r => r !== null);\n\n    if (ratings.length > 0) {\n        stats.avgRating = parseFloat((ratings.reduce((a, b) => a + b, 0) / ratings.length).toFixed(2));\n        stats.fiveStarPct = parseFloat(((ratings.filter(r => r === 5).length / ratings.length) * 100).toFixed(1));\n        stats.fourPlusPct = parseFloat(((ratings.filter(r => r >= 4).length / ratings.length) * 100).toFixed(1));\n        stats.mostCommonRating = getMostCommon(ratings);\n\n        // Rating distribution\n        stats.ratingDistribution = {};\n        for (let i = 1; i <= 5; i++) {\n            const count = ratings.filter(r => r === i).length;\n            if (count > 0) stats.ratingDistribution[i] = count;\n        }\n\n        // Compare to Goodreads average\n        const validComparisons = books.filter(b => parseRating(b.rating) !== null && b.avgRating > 0);\n        if (validComparisons.length > 0) {\n            const diff = validComparisons.reduce((sum, b) => {\n                return sum + (parseRating(b.rating) - b.avgRating);\n            }, 0) / validComparisons.length;\n            stats.ratingVsGoodreads = parseFloat(diff.toFixed(2));\n\n            if (diff > 0.3) {\n                stats.ratingPersonality = \"Generous Reviewer\";\n            } else if (diff < -0.3) {\n                stats.ratingPersonality = \"Tough Critic\";\n            } else {\n                stats.ratingPersonality = \"Balanced Judge\";\n            }\n\n            // NEW: Advanced rating analysis\n            stats.ratingAnalysis = analyzeRatingBehavior(validComparisons);\n        }\n    }\n\n    // Publication year stats\n    const years = books.map(b => parsePublicationYear(b.datePublished)).filter(y => y !== null);\n\n    if (years.length > 0) {\n        stats.avgPubYear = Math.round(years.reduce((a, b) => a + b, 0) / years.length);\n        stats.oldestBookYear = Math.min(...years);\n        stats.newestBookYear = Math.max(...years);\n        stats.timeSpanYears = stats.newestBookYear - stats.oldestBookYear;\n\n        // Find oldest book\n        const oldestBook = books.find(b => parsePublicationYear(b.datePublished) === stats.oldestBookYear);\n        stats.oldestBookTitle = oldestBook?.title || 'Unknown';\n\n        // Era breakdown\n        const eras = years.map(getEra);\n        stats.favoriteEra = getMostCommon(eras);\n        stats.eraBreakdown = countOccurrences(eras);\n\n        // Time period counts\n        stats.books2020Plus = years.filter(y => y >= 2020).length;\n        stats.booksPre1900 = years.filter(y => y < 1900).length;\n        stats.booksAncient = years.filter(y => y < 500).length;\n\n        // Reading personality\n        const ancientPct = stats.booksPre1900 / years.length;\n        const recentPct = stats.books2020Plus / years.length;\n\n        if (ancientPct > 0.3) {\n            stats.readingPersonality = \"Time Traveler\";\n        } else if (recentPct > 0.7) {\n            stats.readingPersonality = \"Trend Chaser\";\n        } else {\n            stats.readingPersonality = \"Balanced Reader\";\n        }\n    }\n\n    // Author stats\n    const authors = books.map(b => b.author).filter(a => a);\n\n    if (authors.length > 0) {\n        stats.uniqueAuthors = new Set(authors).size;\n        stats.booksPerAuthor = parseFloat((authors.length / stats.uniqueAuthors).toFixed(2));\n\n        const authorCounts = countOccurrences(authors);\n        const topAuthor = Object.entries(authorCounts).sort((a, b) => b[1] - a[1])[0];\n        stats.topAuthorName = topAuthor[0];\n        stats.topAuthorCount = topAuthor[1];\n\n        if (authors.length >= 5) {\n            if (stats.booksPerAuthor >= 2.0) {\n                stats.authorLoyalty = \"Superfan\";\n            } else if (stats.booksPerAuthor < 1.2) {\n                stats.authorLoyalty = \"Explorer\";\n            } else {\n                stats.authorLoyalty = \"Balanced\";\n            }\n        }\n    }\n\n    // Genre stats\n    const genres = books.map(b => inferGenre(b.title));\n    stats.topGenre = getMostCommon(genres);\n    stats.genreBreakdown = countOccurrences(genres);\n    stats.genreDiversity = Object.keys(stats.genreBreakdown).length;\n\n    // Goodreads community average\n    const validAvgRatings = books.filter(b => b.avgRating > 0).map(b => b.avgRating);\n    if (validAvgRatings.length > 0) {\n        stats.goodreadsAvg = parseFloat((validAvgRatings.reduce((a, b) => a + b, 0) / validAvgRatings.length).toFixed(2));\n\n        if (stats.avgRating) {\n            const diff = Math.abs(stats.avgRating - stats.goodreadsAvg);\n            if (diff < 0.3) {\n                stats.tasteAlignment = \"Mainstream\";\n            } else if (stats.avgRating > stats.goodreadsAvg) {\n                stats.tasteAlignment = \"Optimist\";\n            } else {\n                stats.tasteAlignment = \"Contrarian\";\n            }\n        }\n    }\n\n    return stats;\n};\n\n// NEW: Analyze rating behavior in detail\nconst analyzeRatingBehavior = (booksWithComparisons) => {\n    const analysis = {};\n\n    // Books where user rated higher than Goodreads\n    const ratedHigher = booksWithComparisons.filter(b => {\n        const userRating = parseRating(b.rating);\n        return userRating > b.avgRating;\n    });\n\n    // Books where user rated lower than Goodreads\n    const ratedLower = booksWithComparisons.filter(b => {\n        const userRating = parseRating(b.rating);\n        return userRating < b.avgRating;\n    });\n\n    // Books rated exactly the same\n    const ratedSame = booksWithComparisons.filter(b => {\n        const userRating = parseRating(b.rating);\n        return Math.abs(userRating - b.avgRating) < 0.1;\n    });\n\n    analysis.ratedHigherCount = ratedHigher.length;\n    analysis.ratedLowerCount = ratedLower.length;\n    analysis.ratedSameCount = ratedSame.length;\n    analysis.ratedHigherPct = parseFloat((ratedHigher.length / booksWithComparisons.length * 100).toFixed(1));\n    analysis.ratedLowerPct = parseFloat((ratedLower.length / booksWithComparisons.length * 100).toFixed(1));\n\n    // Find biggest disagreements\n    const disagreements = booksWithComparisons.map(b => ({\n        title: b.title,\n        userRating: parseRating(b.rating),\n        avgRating: b.avgRating,\n        difference: parseRating(b.rating) - b.avgRating\n    }));\n\n    // Most loved (rated much higher than average)\n    const mostLoved = disagreements\n        .filter(d => d.difference > 0)\n        .sort((a, b) => b.difference - a.difference)\n        .slice(0, 3);\n\n    // Most critical (rated much lower than average)\n    const mostCritical = disagreements\n        .filter(d => d.difference < 0)\n        .sort((a, b) => a.difference - b.difference)\n        .slice(0, 3);\n\n    analysis.mostLoved = mostLoved;\n    analysis.mostCritical = mostCritical;\n\n    // Underrated gems (gave 5 stars, Goodreads average < 4.0)\n    const underratedGems = booksWithComparisons.filter(b => {\n        const userRating = parseRating(b.rating);\n        return userRating === 5 && b.avgRating < 4.0;\n    });\n\n    analysis.underratedGems = underratedGems.map(b => ({\n        title: b.title,\n        avgRating: b.avgRating\n    }));\n\n    // Overrated books (gave 1-2 stars, Goodreads average > 4.0)\n    const overratedBooks = booksWithComparisons.filter(b => {\n        const userRating = parseRating(b.rating);\n        return userRating <= 2 && b.avgRating > 4.0;\n    });\n\n    analysis.overratedBooks = overratedBooks.map(b => ({\n        title: b.title,\n        avgRating: b.avgRating,\n        userRating: parseRating(b.rating)\n    }));\n\n    // Rating consistency - standard deviation\n    const differences = disagreements.map(d => d.difference);\n    const avgDiff = differences.reduce((a, b) => a + b, 0) / differences.length;\n    const variance = differences.reduce((sum, diff) => sum + Math.pow(diff - avgDiff, 2), 0) / differences.length;\n    analysis.ratingStdDev = parseFloat(Math.sqrt(variance).toFixed(2));\n\n    // Determine consistency personality\n    if (analysis.ratingStdDev < 0.5) {\n        analysis.consistencyType = \"Predictable\";\n    } else if (analysis.ratingStdDev > 1.0) {\n        analysis.consistencyType = \"Unpredictable\";\n    } else {\n        analysis.consistencyType = \"Moderate\";\n    }\n\n    // Harsh on popular books?\n    const popularBooks = booksWithComparisons.filter(b => b.avgRating >= 4.2);\n    if (popularBooks.length > 0) {\n        const popularAvgDiff = popularBooks.reduce((sum, b) => {\n            return sum + (parseRating(b.rating) - b.avgRating);\n        }, 0) / popularBooks.length;\n        analysis.harshOnPopular = popularAvgDiff < -0.3;\n    }\n\n    // Champion of underdogs?\n    const unpopularBooks = booksWithComparisons.filter(b => b.avgRating < 3.8);\n    if (unpopularBooks.length > 0) {\n        const unpopularAvgDiff = unpopularBooks.reduce((sum, b) => {\n            return sum + (parseRating(b.rating) - b.avgRating);\n        }, 0) / unpopularBooks.length;\n        analysis.championOfUnderdogs = unpopularAvgDiff > 0.3;\n    }\n\n    return analysis;\n};\n\nconst getMostCommon = (arr) => {\n    const counts = countOccurrences(arr);\n    return Object.entries(counts).sort((a, b) => b[1] - a[1])[0]?.[0];\n};\n\nconst countOccurrences = (arr) => {\n    return arr.reduce((acc, val) => {\n        acc[val] = (acc[val] || 0) + 1;\n        return acc;\n    }, {});\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}